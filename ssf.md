[Вопросы для собеседования](README.md)

# Spring Security
+ [Что такое делегирующий `прокси-фильтр`в Spring Security?](#Что-такое-делегирующий-прокси-фильтр-в-Spring-Security)
+ [Какие существуют ограничения на использование `делегирующего фильтрующего прокси` в системе безопасности Spring?](#Какие-существуют-ограничения-на-использование-делегирующего-фильтрующего-прокси-в-системе-безопасности-Spring)
+ [Будут ли методы `жизненного цикла Fitler`, такие как init и destroy, делегироваться целевому Bean с помощью DelegatingFilterProxy?](#Будут-ли-методы-жизненного-цикла-Fitler,-такие-как-init-и-destroy,-делегироваться-целевому-Bean-с-помощью-DelegatingFilterProxy)
+ [Кто управляет `жизненным циклом Bean` фильтра в Spring?](#Кто-управляет-жизненным-циклом-Bean-фильтра-в-Spring)
+ [Что представляет собой `цепочка фильтров` безопасности в `Spring Security`?](#Что-представляет-собой-цепочка-фильтров-безопасности-в-Spring-Security)
+ [Какие предопределенные фильтры используются в `Spring Security`?](#Какие-предопределенные-фильтры-используются-в-Spring-Security)
+ [Можно ли добавить пользовательские фильтры в цепочку фильтров `Spring security`?](#Можно-ли-добавить-пользовательские-фильтры-в-цепочку-фильтров-Spring-security)
+ [Как реализовать пользовательский `фильтр в Spring Security`?](#Как-реализовать-пользовательский-фильтр-в-Spring-Security)
+ [Как добавить пользовательский фильтр в цепочку фильтров Spring Security?](#Как-добавить-пользовательский-фильтр-в-цепочку-фильтров-Spring-Security)
+ [Является ли безопасность сквозной задачей?](#Является-ли-безопасность-сквозной-задачей)
+ [Для чего используются @ и # в `Spring Expression Language`?](#Для-чего-используются-@-и-#-в-Spring-Expression-Language)
+ [Для каких аннотаций безопасности разрешено использовать `SpEL`?](#Для-каких-аннотаций-безопасности-разрешено-использовать-SpEL)
+ [Что такое `контекст безопасности`?](#Что-такое-контекст-безопасности)
+ [Что такое `аутентификация` и `авторизация`?](#Что-такое-аутентификация-и-авторизация)
+ [Что такое `принцип` в системе безопасности Spring?](#Что-такое-принцип-в-системе-безопасности-Spring)
+ [Зачем нужен `intercept-url`?](#Зачем-нужен-intercept-url)
+ [Зачем нужна защита метода?](#Зачем-нужна-защита-метода)
+ [В каком порядке нужно писать несколько intercept-url'ов?](#В-каком-порядке-нужно-писать-несколько-intercept-url'ов)
+ [Что делают `@Secured` и `@RolesAllowed`?](#Что-делают-@Secured-и-@RolesAllowed)
+ [Поддерживает ли Spring Security хеширование паролей?](#Поддерживает-ли-Spring-Security-хеширование-паролей)
+ [Что такое `PasswordEncoder`?](#то-такое-PasswordEncoder)
+ [Каковы некоторые реализации `PasswordEncoder` в Spring Security?](#Каковы-некоторые-реализации-PasswordEncoder-в-Spring-Security)


## Что такое делегирующий прокси-фильтр в Spring Security?

Делегирующий прокси-фильтр представляет собой общий боб, который обеспечивает связь между web.xml и application-Context.xml. Spring security использует фильтры для реализации нескольких сквозных задач, связанных с безопасностью, таких как аутентификация и авторизация. 

Поскольку фильтры должны быть объявлены в web.xml, контейнер сервлетов может вызвать их перед передачей запроса реальному классу сервлета. 

В системе безопасности Spring эти фильтры также являются бобами Spring, поэтому они могут использовать возможности Spring по инъекции зависимостей, поэтому они объявляются внутри конфигурационного файла Spring, а от их имени в файле web.xmlas объявляется делегирующий прокси фильтра (DelegatingFilterProxy), как показано ниже: 

```xml
<filter>
  <filter-name>springSecurityFilterChain</filter-name>
<filter-class>
     org.springframework.web.filter.DelegatingFilterProxy
</filter-class>
</filter> 

<filter-mapping>
   <filter-name>springSecurityFilterChain</filter-name>
   <url-pattern>/*</url-pattern>
</filter-mapping> 
```

Во время выполнения делегирующий фильтрующий прокси делегирует HTTP-запросы классу бобов для фильтрации. Если вы хотите узнать больше, я предлагаю вам пройти курс Spring Security Core: Beginner to Guru на Udemy, чтобы узнать больше о том, как работает делегирование прокси фильтра в Spring Security. 


[к оглавлению](#Spring-Security)

## Какие существуют ограничения на использование делегирующего фильтрующего прокси в системе безопасности Spring?

Для того чтобы DelegatingFilterProxy работал как положено, существуют некоторые правила и ограничения, которые необходимо соблюдать, например 

- 1) Вы должны объявить делегирующий фильтр-прокси в своем web.xml как фильтр. 

- 2) Целевой боб должен реализовывать интерфейс javax.servlet.Filter.

- 3) Целевой боб должен иметь то же имя, что и в элементе filter-name. 

- 4) В web.xml можно также указать init-параметр фильтра "targetBeanName", чтобы задать имя целевого боба в контексте приложения Spring. 

[к оглавлению](#Spring-Security)

## Будут ли методы жизненного цикла Fitler, такие как init и destroy, делегироваться целевому Bean с помощью DelegatingFilterProxy?

Нет, по умолчанию методы жизненного цикла, определенные интерфейсом Servlet Filter, не будут делегированы целевому бобу, вместо этого жизненным циклом этого боба будет управлять контекст приложения Spring. Он будет отвечать за создание и уничтожение экземпляров бобов фильтра. 

Однако вы можете принудительно вызвать методы жизненного цикла Filter.init() и Filter.destroy() на целевом бобе, указав в init-параметре фильтра "targetFilterLifecycle" значение "true". Это позволит контейнеру сервлетов управлять жизненным циклом фильтра вместо контейнера Spring. 

[к оглавлению](#Spring-Security)

## Кто управляет жизненным циклом Bean фильтра в Spring?

Как объяснялось в предыдущем примере, по умолчанию контейнер Spring управляет жизненным циклом бобов-фильтров Spring, т.е. бобов, реализующих интерфейс Filter и обрабатывающих запросы, делегированные Spring proxy, но вы можете попросить контейнер сервлетов управлять их жизненным циклом, объявив init-параметр фильтра "targetFilterLifecycle" как "true" в web.xml при объявлении фильтра DelegatingFilterProxy, как показано ниже: 

```xml
<filter>
   <filter-name>springSecurityFilterChain</filter-name>
   <filter-class>
      org.springframework.web.filter.DelegatingFilterProxy
   </filter-class>
</filter> 

<filter-mapping>
   <filter-name>springSecurityFilterChain</filter-name>
   <url-pattern>/*</url-pattern>
</filter-mapping>
```

[к оглавлению](#Spring-Security)

## Что представляет собой цепочка фильтров безопасности в Spring Security?

- реймворк Spring Security использует цепочку фильтров для применения различных мер безопасности, таких как перехват запроса, обнаружение (отсутствие) аутентификации, перенаправление на точку входа аутентификации, передача запроса службе авторизации и, в конечном итоге, либо передача запроса сервлету, либо выброс исключения безопасности (неаутентифицированный или неавторизованный). 

- DelegatingFitlerProxy склеивает эти фильтры вместе и образует цепочку фильтров безопасности. Именно поэтому вы видите название "springSecurityFilterChain", когда мы объявляем DelegatingFilterProxy в качестве фильтра в web.xml.  При желании вы можете ознакомиться с курсом Learn Spring Security MasterClass от Eugen Paraschive из Baeldung, чтобы узнать больше об архитектуре безопасности Spring и основных концепциях. 

[к оглавлению](#Spring-Security)

## Какие предопределенные фильтры используются в Spring Security?

Цепочка фильтров безопасности Spring представляет собой очень сложную и гибкую цепочку фильтров. Для выполнения своей задачи эти фильтры обращаются к таким сервисам, как UserDetailsService и AuthenticationManager. Их порядок работы также важен, поскольку перед авторизацией может потребоваться проверка аутентификации. 

Ниже приведены некоторые важные фильтры из цепочки фильтров безопасности Spring в том порядке, в котором они встречаются: 

`SecurityContextPersistenceFilter` - Этот фильтр восстанавливает аутентификацию из cookie JSESSIONID. 

`UsernamePasswordAuthenticationFilter` - Этот фильтр выполняет аутентификацию. 

`ExceptionTranslationFilter` - Этот фильтр перехватывает исключения безопасности от FilterSecurityInterceptor. 

`FilterSecurityInterceptor` - Данный фильтр может выбрасывать исключения аутентификации и авторизации. 


[к оглавлению](#Spring-Security)

## Можно ли добавить пользовательские фильтры в цепочку фильтров Spring security?

Да, вы можете добавлять или заменять отдельные фильтры собственной логикой в цепочке фильтров безопасности Spring. Несмотря на то, что Spring Security предоставляет ряд фильтров по умолчанию, в большинстве случаев их бывает достаточно. В зависимости от требований проекта может потребоваться реализация новой функциональности, и это можно сделать, создав новый фильтр для использования в цепочке. 

[к оглавлению](#Spring-Security)

## Как реализовать пользовательский фильтр в Spring Security?

Вы можете реализовать пользовательский фильтр в системе безопасности Spring, реализовав класс org.springframework.web.filter.GenericFilterBean. `GenericFilterBean` представляет собой простую реализацию javax.servlet.Filter, которая ориентирована на Spring. Вы можете переопределить doFilter(ServletRequest req, ServletResponse res, FilterChain chain), чтобы реализовать собственную логику. 

[к оглавлению](#Spring-Security)

## Как добавить пользовательский фильтр в цепочку фильтров Spring Security?

В зависимости от того, используете ли вы Java-конфигурацию или Spring-конфигурацию, вы можете использовать следующие шаги для добавления пользовательского фильтра в цепочку фильтров безопасности. 

Использование конфигурации XML: 

Вы можете добавить фильтр в цепочку, используя тег custom-filter и один из псевдонимов фильтра, например FORM_LOGIN_FILTER, BASIC_AUTH_FILTER, чтобы указать позицию вашего фильтра. Например, вы можете добавить свой пользовательский фильтр после FORM_LOGIN_FILTER, как показано ниже: 

```xml
<beans:bean id="customSpringScurityFilter" class="CustomSecurityFilter"/> 
<http> 
  <custom-filter after="FORM_LOGIN_FILTER" ref="customSpringScurityFilter" /> 
</http>
```

Здесь указаны все атрибуты, позволяющие точно определить место установки фильтра в цепи пружинных фильтров безопасности: 

`after` - задает фильтр, сразу после которого в цепочке будет добавлен пользовательский фильтр. 

`before `- указывается фильтр, перед которым в цепочке должен располагаться ваш пользовательский фильтр. 

`position` - позволяет заменить стандартный фильтр в явной позиции на пользовательский фильтр безопасности. 


Полный список псевдонимов фильтров безопасности Spring смотрите здесь: 

Кстати, если вы используете Java Configuration, то можете расширить WebSecurityConfigurerAdapter и реализовать его метод configure(HttpSecurity http), чтобы поместить ваш пользовательский фильтр в нужное место в цепочке фильтров безопасности Spring. 

[к оглавлению](#Spring-Security)

## Является ли безопасность сквозной задачей?

`Сквозная проблема` - это проблема, которая применяется во всем приложении и влияет на все приложение. Например, протоколирование, безопасность и передача данных - это проблемы, которые необходимы практически в каждом модуле приложения, поэтому они являются сквозными. 

Различные уровни безопасности реализуются по-разному, например, безопасность на уровне методов реализуется с помощью AOP. Фреймворк Spring Security также использует фильтры для реализации безопасности. Кроме того, вы можете ознакомиться с основами Spring Security и узнать больше об аутентификации и авторизации в Spring Security. 

[к оглавлению](#Spring-Security)

## Для чего используются @ и # в Spring Expression Language?

Символ "@" в Spring EL используется для ссылки на Spring Bean, а символ "#" в Spring EL позволяет сослаться на параметр в защищаемом методе. 

[к оглавлению](#Spring-Security)

## Для каких аннотаций безопасности разрешено использовать SpEL?

Аннотация @PreAuthorize является одной из самых мощных аннотаций в системе безопасности Spring, которая разрешена для использования в SpEL, но старая аннотация @Secured не разрешена для использования в SpEL, например, вы не можете написать @Secured ("hasRole('ROLEADMIN')"), но можете @PreAuthorize("hasRole('ROLEADMIN')"). 

[к оглавлению](#Spring-Security)

## Что такое контекст безопасности?

`SecurityContext` - это интерфейс фреймворка Spring Security, определяющий минимальную информацию о безопасности, связанную с текущим потоком выполнения. Он предоставляет такие методы, как getAuthentication(), которые могут использоваться для получения текущего аутентифицированного принципала или маркера запроса аутентификации. При отсутствии информации об аутентификации возвращается null.  Более подробную информацию о нем можно найти в моей статье Spring Security Context. 

[к оглавлению](#Spring-Security)

## Что такое аутентификация и авторизация?

`Аутентификация `- это процесс проверки того, что пользователь является тем, за кого он себя выдает. Обычно она осуществляется с помощью имени пользователя и пароля. Если пользователь вводит правильное имя пользователя и пароль, то аутентификация проходит успешно, в противном случае аутентификация не проходит. 

`Авторизация` обеспечивает контроль доступа. Например, некоторые страницы в веб-приложении может видеть только администратор. Для этого администратор должен обладать некоторыми правами или ролями, связанными с администрацией. 

Если пользователь становится администратором, то эти права добавляются к данному профилю. Если вы имеете доступ к какой-либо странице, это означает, что вы авторизованы на этой странице или ресурсах. Очевидно, что авторизация происходит после аутентификации, поскольку доступ может быть предоставлен только подлинным пользователям. 


[к оглавлению](#Spring-Security)

## Что такое принцип в системе безопасности Spring?

В действительности принципом является пользователь, вошедший в систему в данный момент. Вы можете получить контекст безопасности, который привязан к текущему потоку и, таким образом, привязан к текущему запросу и его сессии. Внутренняя функция SecurityContextHolder.getContext() получает текущую реализацию SecurityContext через переменную ThreadLocal. Поскольку запрос привязан к одному потоку, то в этом случае будет получен контекст текущего запроса.


[к оглавлению](#Spring-Security)

## Зачем нужен intercept-url?

`Intercept-url` необходим для защиты URL-адресов в Java-веб-приложении с помощью Spring security. Он также определяет своего рода авторизацию, то есть разрешение или доступ, который требуется пользователю для просмотра страницы или URL. В большинстве веб-приложений, использующих Spring Security, имеется только пара intercept-url, поскольку они предъявляют только базовые требования к безопасности. 

Вам необходимо иметь неаутентифицированный или анонимный доступ к экранам входа в систему и ошибок входа, а также, как правило, к некоторым аспектам публичного сайта, которые можно перехватить с помощью нескольких шаблонов URL. Затем часто имеется раздел администратора для администрирования, например, для создания ролей, пользователей или разрешений, а все остальное - ROLE_USER.

Вот один из примеров базовой безопасности Spring с использованием перехвата URL:

```xml
<http realm="Contacts Realm" use-expressions="false">. 
   <intercept-url pattern="/index.jsp" access="IS_AUTHENTICATED_ANONYMOUSLY"/> 
   <intercept-url pattern="/login.jsp*" access="IS_AUTHENTICATED_ANONYMOUSLY"/> 
   <intercept-url pattern="/admin/*" access="ROLE_ADMIN"/>. 
   <intercept-url pattern="/trade/*" access="ROLE_TRADER"/> 
   <intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN,ROLE_TRADER"/>. 
   <http-basic/> 
</http>
```
Видно, что к index.jsp и admin.jsp разрешен доступ без аутентификации. Все, что содержит admin в URL, требует доступа ROLE_ADMIN, а все URL, содержащие trade, требуют доступа ROLE_TRADER. 

Начиная с Spring 3.0, Spring также позволяет управлять доступом на основе выражений, но это не является обязательным, хотя и дает больше возможностей для реализации сложных механизмов доступа. Если вы хотите узнать больше об аутентификации и авторизации на spring-security, то вы также можете ознакомиться с курсом OAuth 2.0 в Spring Boot Applications на Udemy. 

[к оглавлению](#Spring-Security)

## Зачем нужна защита метода?

Безопасность - дело непростое, часто требуется несколько уровней безопасности, чтобы повысить шансы блокировать попытки обхода. Поскольку безопасность на уровне метода кодируется непосредственно внутри класса, после расширения AOP при вызове метода всегда будет выполняться проверка безопасности. 

Защита на уровне метода полезна по двум основным причинам: 

1. Обеспечивает еще один уровень безопасности (в дополнение к другим уровням)

2. В случаях, когда удобнее или логичнее иметь права на уровне метода, рассмотрим случай, когда разные пользователи могут выполнять одни и те же "прямые" действия (поэтому безопасность клиента не имеет значения). Но в некоторых случаях их действия могут вызвать поведение, которое вы хотите ограничить - в этом случае безопасность на уровне метода может быть уместным решением. 

[к оглавлению](#Spring-Security)

## В каком порядке нужно писать несколько intercept-url'ов?

Если у вас несколько URL-адресов перехвата, то их следует записывать от более конкретного к менее конкретному. Поскольку шаблоны intercept-url обрабатываются в том порядке, в котором они появляются в конфигурационном файле spring security, важно, чтобы URL совпадал с нужным шаблоном. 

Это становится еще более важным, когда в шаблонах URL присутствуют подстановочные знаки. 

В следующем примере все входящие запросы, не соответствующие ни одному из определенных шаблонов, будут отклонены, поскольку "<intercept-url pattern="/**" access="denyAll" />" является последним шаблоном, который должен быть сопоставлен. 

```xml
<http use-expressions="true">. 
   <intercept-url pattern="/index.jsp" access="permitAll" /> 
   <intercept-url pattern="/secure/admin/**" access="hasRole('admin')" /> 
   <intercept-url pattern="/secure/**" access="isAuthenticated()" />. 
   <intercept-url pattern="/listAccounts.html" access="isAuthenticated()" />. 
   <intercept-url pattern="/post.html" access="hasAnyRole('supervisor','teller')" /> 
   <intercept-url pattern="/**" access="denyAll" />. 
   <form-login /> 
</http>
```

Поэтому наиболее специфичные шаблоны должны стоять на первом месте, поскольку они проверяются именно в таком порядке. Один из подходов заключается в том, чтобы сначала определить белый список URL, а затем запретить все остальные. 

[к оглавлению](#Spring-Security)

## Что делают @Secured и @RolesAllowed?

Аннотация `@Secured` используется для определения списка атрибутов конфигурации безопасности для бизнес-методов. С помощью аннотации @Secured можно указать требования безопасности [роли/разрешения и т.д.] к методу, и тогда только пользователь с такими ролями/разрешениями сможет вызывать этот метод. 

Если кто-то попытается вызвать метод, не обладая необходимыми ролями/разрешениями, то будет выброшено исключение AccessDeniedException. 

Приведем простой пример использования аннотации @Secured: 

```java
@Secured({"ROLE_ADMIN"}) 
public String showTrades() { 
   return "secure/trades"; 
}
```

Функция @Secured пришла из предыдущих версий Spring. Его ограничение заключается в том, что он не поддерживает выражения Spring EL. 

Лучше заменить аннотацию @Secured на аннотацию @PreAuthorize, которая поддерживает Spring EL. Например, приведенный выше код может быть написан с использованием `@PreAuthorize` следующим образом: 

```java
@PreAuthorize("hasRole('ROLEADMIN')") 
public String showTrades() { 
   return "secure/trades"; 
}
```

С другой стороны, `@RolesAllowed` - это аннотация JSR 250, определяющая роли безопасности, которым разрешен доступ к методу или нескольким методам в приложении. 

Если вы не знакомы с JSR 250, то его целью является определение общих аннотаций для платформы Java, и если вы хотите узнать больше об основных аннотациях безопасности Spring, то для начала вы можете выбрать хороший курс, упомянутый в этих лучших курсах по безопасности Spring. 


[к оглавлению](#Spring-Security)

## Поддерживает ли Spring Security хеширование паролей?

Одной из распространенных проблем хранения паролей в базах данных является их безопасность. Нельзя хранить в базе данных пароли в виде обычного текста, поскольку в этом случае любой, кто имеет доступ к базе данных, будет иметь доступ к паролю каждого пользователя. Для решения этой проблемы в базе данных хранятся зашифрованные пароли, что называется хешированием паролей. 

В криптографии соль - это случайные данные, которые комбинируются с паролем перед его хешированием. Это делает атаку по словарю более сложной. Этот процесс известен как солеобразование. Хешированная версия пароля хранится в базе данных вместе с солью. 

Кстати, некоторые алгоритмы хеширования не подходят для хеширования паролей, если соль слишком мала или предсказуема, то можно восстановить пароли, сопоставив случайные слова с солью и сравнив полученную хешированную версию с данными, хранящимися в базе. 

Да, Spring Security включает хеширование паролей из коробки. Начиная с версии 3.1, Spring Security автоматически заботится и о высаливании. Для реализации хеширования паролей в Spring Security можно использовать реализацию PasswordEncoderimplementation. 

[к оглавлению](#Spring-Security)

## Что такое PasswordEncoder?

`PasswordEncoder` - это интерфейс в системе безопасности Spring, обеспечивающий кодирование или хеширование паролей. Он имеет два метода encode() для кодирования исходного пароля и matches()для проверки соответствия кодированного пароля, полученного из базы данных, исходному паролю после его кодирования с использованием той же соли и того же алгоритма хеширования

[к оглавлению](#Spring-Security)

## Каковы некоторые реализации PasswordEncoder в Spring Security?

`Spring security` предоставляет несколько реализаций, основанных на различных алгоритмах хеширования, которые вы можете использовать в своих приложениях. Две важные реализации нового интерфейса PasswordEncoder - это BCryptPasswordEncoder и путано названный StandardPasswordEncoder, основанный на SHA-256. Рекомендуется использовать реализацию BCrypt. Существует также NoOpPasswordEncoder, который не выполняет никакого кодирования. Он предназначен только для модульного тестирования. 

[к оглавлению](#Spring-Security)
